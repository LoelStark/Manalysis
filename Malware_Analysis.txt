#This review is for educational purposes Only and I will not be deemed responsible for any misuse of the instructions or notes below
*******************************************************************************************************************************

// MALWARE ANALYSIS //

*Before the full detailed description, for those who are new or unfamiliar I'll go through a few common things

32 - Bit Process
- ADDRESS SIZE = 4 bytes
- WORD = 2 bytes
- DWORD = 4 bytes
- QWORD = 8 Bytes

64 - Bit Process
- ADDRESS SIZE = 4 bytes
- WORD = 4 bytes
- DWORD = 4 bytes
- QWORD = 8 bytes

Shell code = Code that is written or generated for a specific function, typically written in assembly.
We mostly use Shell Code to Bypass encryption

//Injection Attacks//

*FIleless Attacks
- Attacks that only take place in the memory without touching the disk, these are also very important for avoiding detection and common antiviruses.

Injection attacks have 3 stages:
1. Allocate Memory (for the shell code)
2. Write the shell code into the allocated memory
3. Execute the shell code

**Now lets go through a bit of self injection

// Self Injection //

- If we were to write our malware in C (Reason being, C is the most common language when writing memory related program, whether its process scheduling, etc...
- We'll first begin with header files, these can be your " #include <windows.h" and your "#include <stdio.h> "
- Header files are the ones which contain predefined functions, structs, etc.. (They are commonly used and very important")
- We'll first begin with creating a function that will define our shell code, with shell code you can write it from scratch if you are familiar with assembly or you can generate it using metasploit on kali Linux (I mentioned Kali because its the one I'm familiar with and mostly use for day to day tasks)
** Lets go through how to generate shell code using Metasploit in Linux

- type msfconsole (Its the command used to open metasploit on a linux terminal)
- if its not there use sudo apt install msfconsole (to download it)
- now after opening msfconsole, tyep use payload/windows/x64
(I used x64 because I use a 64 bit processing system)
- For this concept we are not making anything extreme, we'll use generate a basic message box 
- As for the payloads, we're looking for a windows payload
- Type use payload/windows/messagebox
- Once selected, type show options
- Under text, set your desired text and leave the title as is
- Generate

//Remember the first step for the self injection malware is to allocate memory
This is where windows API come in, under the header files I made an example with "#include <windows.h>"
this header files allows the execution and utilization of windows API functions

- We'll start with VirtualAlloc() API
Which uses 4 parameters and I'll explain every single one of them below, by the end of your VirtualAlloc API it should look something like = #VirtualAlloc(NULL, sizeof(shellcode), (MEM_COMMIT|MEM_RESERVE), PAGE_EXECUTE_READ_WRITE)
I'll explain each parameter as we go.

1. NULL
- Since we don't know where exactly in the memory we're allocating/Assigning the self Injection we use NULL and let the operating system pick for us
2. sizeof(shellcode)
- This is how much memory you are willing to allocate and since we generated the shellcode using a terminal we'll set the size of the memory we're allocating to the shellcode
3. MEM_COMMIT|MEM_RESERVE
According to Microsoft MEM_COMMIT guidelines, 
"YOu can only commit reserved pages in subsequent calls to the virtualalloc function. To reserve and commit pages in one step, call the function with MEM_COMMIT|MEM_RESERVE"

- Ok, so when we want to allocate a page a block of memory we first have to reserve it, hence (MEM_RESERVE)
- Then after we reserve it, we need to commit, hence (MEM_COMMIT), this is us telling the operating system we want to read and write in this block of memory
- As you've noticed in order to use both of this we need to pipe them, piping it like the "OR" logic
